<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Primary Meta Tags -->
    <title>Uber Wrapped ‚Äì Visualize Your Uber Ride & Eats Statistics | Year in Review</title>
    <meta name="title" content="Uber Wrapped ‚Äì Visualize Your Uber Ride & Eats Statistics | Year in Review">
    <meta name="description" content="Create your personal Uber Wrapped! Upload your Uber data export to visualize your trips, spending, top destinations, Uber Eats orders, and more ‚Äì all processed locally in your browser.">
    <meta name="keywords" content="Uber Wrapped, Uber year in review, Uber statistics, Uber data visualization, ride history, Uber Eats wrapped, trip analysis">
    <meta name="author" content="Aaron Palmer">
    <meta name="robots" content="index, follow">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://palmerac.github.io/uber-wrapped/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://palmerac.github.io/uber-wrapped/">
    <meta property="og:title" content="Uber Wrapped ‚Äì Your Year in Rides & Eats">
    <meta property="og:description" content="Visualize your Uber journey: trips, spending, destinations, and Uber Eats orders. All processed locally ‚Äì your data never leaves your browser.">
    <meta property="og:image" content="https://palmerac.github.io/uber-wrapped/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Uber Wrapped">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://palmerac.github.io/uber-wrapped/">
    <meta name="twitter:title" content="Uber Wrapped ‚Äì Your Year in Rides & Eats">
    <meta name="twitter:description" content="Create your personal Uber year in review! Visualize trips, spending, and Uber Eats orders.">
    <meta name="twitter:image" content="https://palmerac.github.io/uber-wrapped/og-image.png">
    
    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Uber Wrapped",
        "description": "Visualize your Uber ride and Uber Eats statistics in a Spotify Wrapped-style dashboard. All data processing happens locally in your browser.",
        "url": "https://palmerac.github.io/uber-wrapped/",
        "applicationCategory": "Utility",
        "operatingSystem": "Any",
        "browserRequirements": "Requires JavaScript",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "author": {
            "@type": "Person",
            "name": "Aaron Palmer",
            "url": "https://github.com/palmerac"
        }
    }
    </script>
    
    <link rel="stylesheet" href="style.css">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet Heat -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <!-- html2canvas for screenshot export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>

    <main>
    <!-- Dropzone Landing Screen -->
    <section id="dropzone-screen" class="dropzone-screen" aria-label="Data Upload">
        <div class="landing-header">
            <h1 class="landing-title">Uber Wrapped</h1>
            <p class="landing-tagline">Your year in rides and eats ‚Äî Spotify Wrapped style</p>
        </div>
        <div class="dropzone-container">
            <div class="dropzone" id="dropzone" role="button" aria-label="Drop zone for Uber data folder">
                <div class="dropzone-icon" aria-hidden="true">üìÅ</div>
                <h2>Drop Your Uber Data Folder Here</h2>
                <p>Or click to select your folder</p>
                <input type="file" id="folder-input" webkitdirectory directory multiple hidden aria-label="Select Uber data folder" />
                <button class="dropzone-button" id="select-folder-btn">Select Folder</button>
            </div>
            <aside class="dropzone-info">
                <h3>How to get your Uber data:</h3>
                <ol>
                    <li>Go to <a href="https://myprivacy.uber.com/privacy/exploreyourdata/download" target="_blank" rel="noopener noreferrer">Uber Privacy Center</a></li>
                    <li>Request a copy of your data</li>
                    <li>Download and unzip the folder</li>
                    <li>Drop the entire <strong>Uber Data</strong> folder here</li>
                </ol>
                <p class="privacy-note">üîí <strong>Your data never leaves your browser.</strong> All processing happens locally on your device.</p>
            </aside>
        </div>
        <div id="loading-indicator" class="loading-indicator" style="display: none;" aria-live="polite">
            <div class="spinner" aria-hidden="true"></div>
            <p>Processing your data...</p>
        </div>
        <div id="error-message" class="error-message" style="display: none;" role="alert"></div>
    </section>

    <!-- Dashboard (hidden until data is loaded) -->
    <section id="dashboard" class="container" style="display: none;" aria-label="Uber Statistics Dashboard">
        <header>
            <div class="header-left">
                <h1>Uber Wrapped.</h1>
                <div class="subtitle">Your Life on the Move</div>
            </div>
            
            <div class="profile-bar" id="profile-section">
                <!-- Injected via JS -->
            </div>

            <div class="header-controls">
                <div class="year-selector-container">
                    <select id="year-select"></select>
                    <span class="year-arrow">‚ñº</span>
                </div>
                <button class="reset-button" id="reset-btn" title="Load different data">‚Üª</button>
            </div>
        </header>

        <!-- Hero Section (New) -->
        <section class="hero-section" id="hero-section">
            <div class="hero-eyebrow">Uber Wrapped</div>
            <h2 class="hero-title" id="hero-title">Rides Wrapped</h2>

            <div class="hero-big-stat">
                <span id="hero-primary-value">0</span>
                <span id="hero-primary-label">Rides</span>
            </div>

            <div class="hero-meta-row" id="hero-meta-row">
                <!-- Injected via JS -->
            </div>
        </section>

        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button data-mode="rides" class="mode-btn active" id="mode-rides">Rides</button>
            <button data-mode="eats" class="mode-btn" id="mode-eats">Eats</button>
        </div>

        <!-- RIDES SECTION -->
        <section id="rides-section" class="mode-content-section">
            
            <!-- Map Section -->
            <div class="section-container">
                <div class="map-container">
                    <div id="trip-map"></div>
                    <div class="map-legend">
                        <div class="legend-item"><div class="legend-dot pickup"></div><span>Pickups</span></div>
                        <div class="legend-item"><div class="legend-dot dropoff"></div><span>Dropoffs</span></div>
                    </div>
                </div>
            </div>

            <!-- Behavior Section -->
            <section class="section behavior-section">
                <h3>Your Habits</h3>
                <div class="behavior-grid">
                    <div class="chart-card">
                        <h4>Weekly Habits</h4>
                        <div class="chart-container-inner">
                            <canvas id="day-of-week-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h4>Time of Day</h4>
                        <div class="bar-chart" id="time-chart"></div>
                    </div>
                </div>
            </section>

            <!-- Favorites Section (Lists) -->
            <section class="section favorites-section">
                <h3>Where You Went</h3>
                <div class="ranked-list" id="top-cities"></div>
            </section>

            <!-- Highlights Section -->
            <section class="section highlights-section">
                <h3>Highlights</h3>
                <div class="highlight-row" id="rides-highlights">
                    <!-- Chips injected via JS -->
                </div>
            </section>
        </section>

        <!-- EATS SECTION (Hidden by default) -->
        <section id="eats-section" class="mode-content-section" style="display: none;">
            
            <!-- Behavior Section -->
            <section class="section behavior-section">
                <h3>Your Habits</h3>
                <div class="behavior-grid">
                    <div class="chart-card">
                        <h4>Weekly Habits</h4>
                        <div class="chart-container-inner">
                            <canvas id="eats-day-of-week-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h4>When You Order</h4>
                        <div class="bar-chart" id="eats-time-chart"></div>
                    </div>
                </div>
            </section>

            <!-- Favorites Section -->
            <section class="section favorites-section">
                <h3>Your Favorites</h3>
                <div class="two-col-list">
                    <div>
                        <h4>Top Restaurants</h4>
                        <div class="ranked-list" id="top-restaurants"></div>
                    </div>
                    <div>
                        <h4>Top Cravings</h4>
                        <div class="ranked-list" id="top-items"></div>
                    </div>
                </div>
            </section>

            <!-- Highlights Section -->
            <section class="section highlights-section">
                <h3>Highlights</h3>
                <div class="highlight-row" id="eats-highlights">
                    <!-- Chips injected via JS -->
                </div>
                
                <div id="no-eats-msg" style="text-align: center; padding: 40px; display: none; opacity: 0.7;">
                    Looks like you cooked at home this year! üç≥
                </div>
            </section>
        </section>

        <!-- Share Section -->
        <section class="share-section">
            <h3>Share Your Wrapped</h3>
            <div class="share-buttons">
                <button class="share-btn rides" id="share-rides-btn">
                    <span class="icon">üì∏</span> Share Rides
                </button>
                <button class="share-btn eats" id="share-eats-btn">
                    <span class="icon">üì∏</span> Share Eats
                </button>
            </div>
        </section>

        <footer>
            <p style="margin-top: 20px;">Generated locally from your data privacy export. Not affiliated with Uber.</p>
            <p><a href="https://github.com/palmerac/uber-wrapped" target="_blank" rel="noopener noreferrer">View on GitHub</a></p>
        </footer>
    </section>
    </main>

    <!-- Hidden Share Templates for Screenshot Export -->
    <div id="rides-share-template" class="share-template rides-template">
        <div class="template-header">
            <div class="template-logo">üöó</div>
            <div class="template-title">Uber Wrapped</div>
            <div class="template-year" id="share-rides-year">2024</div>
        </div>
        <div class="template-content">
            <div class="big-stat">
                <div class="big-stat-value" id="share-rides-count">0</div>
                <div class="big-stat-label">Rides</div>
            </div>
            <div class="stats-row" style="justify-content: center;">
                <div class="stat-item">
                    <div class="stat-value" id="share-rides-miles">0</div>
                    <div class="stat-label">Miles</div>
                </div>
            </div>
            <div class="streak-badge" id="share-rides-streak-badge" style="display: none;">
                <div class="streak-fire">üî•</div>
                <div class="streak-text">
                    <div class="streak-value" id="share-rides-streak">0</div>
                    <div class="streak-label">Day Streak</div>
                </div>
            </div>
            <div class="list-section">
                <div class="list-title">Top Destinations</div>
                <div class="list-items" id="share-rides-destinations"></div>
            </div>
            <div class="list-section">
                <div class="list-title">Weekly Habits</div>
                <div class="chart-container" style="position: relative; height: 280px; width: 100%;">
                     <canvas id="share-rides-dow-chart"></canvas>
                </div>
            </div>
            <div class="list-section">
                <div class="list-title">When You Ride</div>
                <div class="time-chart-share" id="share-rides-time-chart"></div>
            </div>
        </div>
        <div class="template-footer">
            <div class="template-url">uber-wrapped.pages.dev</div>
            <div class="template-cta">Create your own Uber Wrapped!</div>
        </div>
    </div>

    <div id="eats-share-template" class="share-template eats-template">
        <div class="template-header">
            <div class="template-logo">üçî</div>
            <div class="template-title">Uber Eats Wrapped</div>
            <div class="template-year" id="share-eats-year">2024</div>
        </div>
        <div class="template-content">
            <div class="big-stat">
                <div class="big-stat-value" id="share-eats-count">0</div>
                <div class="big-stat-label">Orders</div>
            </div>
            <div class="streak-badge" id="share-eats-streak-badge" style="display: none;">
                <div class="streak-fire">üî•</div>
                <div class="streak-text">
                    <div class="streak-value" id="share-eats-streak">0</div>
                    <div class="streak-label">Day Streak</div>
                </div>
            </div>
            <div class="list-section">
                <div class="list-title">Top Spots</div>
                <div class="list-items" id="share-eats-restaurants"></div>
            </div>
            <div class="list-section">
                <div class="list-title">Top Cravings</div>
                <div class="list-items" id="share-eats-items"></div>
            </div>
            <!-- Eats Day of Week section in share template -->
             <div class="list-section">
                 <div class="list-title">Weekly Habits</div>
                 <div class="chart-container" style="position: relative; height: 350px; width: 100%;">
                      <canvas id="share-eats-dow-chart"></canvas>
                 </div>
             </div>
        </div>
        <div class="template-footer">
            <div class="template-url">uber-wrapped.pages.dev</div>
            <div class="template-cta">Create your own Uber Wrapped!</div>
        </div>
    </div>

    <script>
        // ==========================================
        // CSV PARSING UTILITIES
        // ==========================================
        
        // parseCSV functions removed in favor of Papa Parse library

        // ==========================================
        // DATA ANALYSIS FUNCTIONS
        // ==========================================

        function initStats() {
            return {
                trips: [],
                totalSpent: 0,
                totalMiles: 0,
                cityCounts: {},
                timeOfDayCounts: { morning: 0, afternoon: 0, evening: 0, night: 0 },
                totalMovingTimeSeconds: 0,
                rideTypes: {},
                surgeCount: 0,
                totalSurgeMultiplier: 0,
                surgeTripCount: 0,
                splitFareCount: 0,
                multiDestCount: 0,
                uniqueOrders: {},
                restaurantCounts: {},
                restaurantSpend: {},
                itemCounts: {},
                heatmapData: { pickup: [], dropoff: [] },
                tripDates: new Set(),    // Track unique dates for streak calculation
                orderDates: new Set(),   // Track unique order dates for streak calculation
                dayOfWeekCounts: [0, 0, 0, 0, 0, 0, 0], // 0=Sun, 6=Sat
                orderTimeOfDayCounts: { morning: 0, afternoon: 0, evening: 0, night: 0 }
            };
        }

        function updateTripStats(stats, t) {
            const fare = parseFloat(t.fare_amount || t.client_upfront_fare_local || t.original_fare_local || 0);
            if (!isNaN(fare)) stats.totalSpent += fare;

            const miles = parseFloat(t.trip_distance_miles || 0);
            if (!isNaN(miles)) stats.totalMiles += miles;

            if (t.city_name) {
                stats.cityCounts[t.city_name] = (stats.cityCounts[t.city_name] || 0) + 1;
            }

            // Consolidate date parsing
            const dateStr = t.request_timestamp_local || t.request_timestamp_utc;
            if (dateStr) {
                const localDate = new Date(dateStr);
                if (!isNaN(localDate.getTime())) {
                    // Time of Day
                    const hour = localDate.getHours();
                    if (hour >= 5 && hour < 12) stats.timeOfDayCounts.morning++;
                    else if (hour >= 12 && hour < 17) stats.timeOfDayCounts.afternoon++;
                    else if (hour >= 17 && hour < 21) stats.timeOfDayCounts.evening++;
                    else stats.timeOfDayCounts.night++;

                    // Day of Week
                    stats.dayOfWeekCounts[localDate.getDay()]++;

                    // Streak Calculation
                    const tripDate = localDate.toISOString().split('T')[0];
                    stats.tripDates.add(tripDate);
                }
            }

            const duration = parseFloat(t.trip_duration_seconds || 0);
            if (!isNaN(duration)) stats.totalMovingTimeSeconds += duration;

            let type = t.product_type_name || 'Unknown';
            if (type.toLowerCase() === 'uberxl') type = 'UberXL';
            if (type.toLowerCase() === 'uberx') type = 'UberX';
            stats.rideTypes[type] = (stats.rideTypes[type] || 0) + 1;

            if (t.is_surged === 'true' || t.is_surged === true) {
                stats.surgeCount++;
            }
            const multiplier = parseFloat(t.surge_multiplier || 1);
            if (!isNaN(multiplier) && multiplier > 1) {
                stats.totalSurgeMultiplier += multiplier;
                stats.surgeTripCount++;
            }

            if (t.is_fare_split === 'true' || t.is_fare_split === true) {
                stats.splitFareCount++;
            }

            if (t.is_multidestination === 'true' || t.is_multidestination === true) {
                stats.multiDestCount++;
            }

            if (t.begintrip_lat && t.begintrip_lng) {
                const lat = parseFloat(t.begintrip_lat);
                const lng = parseFloat(t.begintrip_lng);
                if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                    stats.heatmapData.pickup.push([lat, lng]);
                }
            }

            if (t.dropoff_lat && t.dropoff_lng) {
                const lat = parseFloat(t.dropoff_lat);
                const lng = parseFloat(t.dropoff_lng);
                if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                    stats.heatmapData.dropoff.push([lat, lng]);
                }
            }
        }

        // Calculate maximum streak of consecutive days
        function calculateMaxStreak(dateSet) {
            if (!dateSet || dateSet.size === 0) return 0;
            
            const sortedDates = Array.from(dateSet).sort();
            let maxStreak = 1;
            let currentStreak = 1;
            
            for (let i = 1; i < sortedDates.length; i++) {
                const prevDate = new Date(sortedDates[i - 1]);
                const currDate = new Date(sortedDates[i]);
                const diffDays = (currDate - prevDate) / (1000 * 60 * 60 * 24);
                
                if (diffDays === 1) {
                    currentStreak++;
                    maxStreak = Math.max(maxStreak, currentStreak);
                } else if (diffDays > 1) {
                    currentStreak = 1;
                }
                // If diffDays === 0, it's a duplicate date, skip
            }
            
            return maxStreak;
        }

        function formatTripStats(stats, tripCount) {
            const topCities = Object.entries(stats.cityCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([city, count]) => ({ city, count }));

            const topRideTypes = Object.entries(stats.rideTypes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([type, count]) => ({ type, count }));

            return {
                totalTrips: tripCount,
                totalSpent: stats.totalSpent.toFixed(2),
                totalMiles: stats.totalMiles.toFixed(2),
                topCities,
                timeOfDayCounts: stats.timeOfDayCounts,
                totalDurationHours: (stats.totalMovingTimeSeconds / 3600).toFixed(1),
                rideTypes: topRideTypes,
                surgeCount: stats.surgeCount,
                avgSurgeMultiplier: stats.surgeTripCount > 0 ? (stats.totalSurgeMultiplier / stats.surgeTripCount).toFixed(2) : 0,
                splitFareCount: stats.splitFareCount,
                multiDestCount: stats.multiDestCount,
                heatmapData: stats.heatmapData,
                heatmapData: stats.heatmapData,
                maxStreak: calculateMaxStreak(stats.tripDates),
                dayOfWeekCounts: stats.dayOfWeekCounts
            };
        }

        function analyzeTrips(trips) {
            const years = {};
            const lifetime = initStats();
            let lifetimeTripCount = 0;

            trips.forEach(t => {
                if (t.status !== 'completed') return;

                const dateStr = t.request_timestamp_utc || t.request_timestamp_local;
                if (!dateStr) return;

                const date = new Date(dateStr);
                const year = date.getFullYear();

                if (!years[year]) {
                    years[year] = { stats: initStats(), count: 0 };
                }

                years[year].count++;
                lifetimeTripCount++;

                updateTripStats(years[year].stats, t);
                updateTripStats(lifetime, t);
            });

            const result = { years: {}, lifetime: formatTripStats(lifetime, lifetimeTripCount) };
            for (const year in years) {
                result.years[year] = formatTripStats(years[year].stats, years[year].count);
            }
            return result;
        }

        function updateOrderStats(stats, o) {
            const orderKey = o.Request_Time_Local + (o.Restaurant_Name || '');

            if (!stats.uniqueOrders[orderKey]) {
                stats.uniqueOrders[orderKey] = {
                    price: parseFloat(o.Order_Price || 0)
                };
                stats.totalSpent += stats.uniqueOrders[orderKey].price;

                if (o.Restaurant_Name) {
                    let name = o.Restaurant_Name.replace(/\s*\(.*?\)\s*/g, '').trim();
                    stats.restaurantCounts[name] = (stats.restaurantCounts[name] || 0) + 1;
                    stats.restaurantSpend[name] = (stats.restaurantSpend[name] || 0) + stats.uniqueOrders[orderKey].price;
                }
            }

            const itemName = o.Item_Name;
            if (itemName) {
                stats.itemCounts[itemName] = (stats.itemCounts[itemName] || 0) + parseInt(o.Item_quantity || 1);
            }

            // Track order date for streak calculation and time of day
            const dateStr = o.Request_Time_Local;
            if (dateStr) {
                const date = new Date(dateStr);
                const orderDate = date.toISOString().split('T')[0];
                stats.orderDates.add(orderDate);
                stats.dayOfWeekCounts[date.getDay()]++;
                
                // Time of day for orders
                const hour = date.getHours();
                if (hour >= 5 && hour < 12) stats.orderTimeOfDayCounts.morning++;
                else if (hour >= 12 && hour < 17) stats.orderTimeOfDayCounts.afternoon++;
                else if (hour >= 17 && hour < 21) stats.orderTimeOfDayCounts.evening++;
                else stats.orderTimeOfDayCounts.night++;
            }
        }

        function formatOrderStats(stats) {
            const topRestaurants = Object.entries(stats.restaurantCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([name, count]) => ({
                    name,
                    count,
                    spend: (stats.restaurantSpend[name] || 0).toFixed(2)
                }));

            const topItems = Object.entries(stats.itemCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([name, count]) => ({ name, count }));

            return {
                totalOrders: Object.keys(stats.uniqueOrders).length,
                totalSpent: stats.totalSpent.toFixed(2),
                topRestaurants,
                topItems,
                maxStreak: calculateMaxStreak(stats.orderDates),
                dayOfWeekCounts: stats.dayOfWeekCounts,
                timeOfDayCounts: stats.orderTimeOfDayCounts
            };
        }

        function analyzeOrders(orders) {
            const years = {};
            const lifetime = initStats();

            orders.forEach(o => {
                if (o.Order_Status !== 'completed' && o.Order_Status !== '') {
                    // Skip non-completed orders
                }

                const dateStr = o.Request_Time_Local;
                if (!dateStr) return;
                const date = new Date(dateStr);
                const year = date.getFullYear();

                if (!years[year]) {
                    years[year] = initStats();
                }

                updateOrderStats(years[year], o);
                updateOrderStats(lifetime, o);
            });

            const result = { years: {}, lifetime: formatOrderStats(lifetime) };
            for (const year in years) {
                result.years[year] = formatOrderStats(years[year]);
            }

            return result;
        }

        function getProfileInfo(profileData, ratingsData) {
            let memberSince = 'Unknown';
            if (profileData.length > 0 && profileData[0]['Signup Date']) {
                const d = new Date(profileData[0]['Signup Date']);
                memberSince = d.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }

            let avgRating = 0;
            if (ratingsData.length > 0) {
                const ratings = ratingsData.map(r => parseInt(r.five_star_rating)).filter(r => !isNaN(r));
                if (ratings.length > 0) {
                    const sum = ratings.reduce((a, b) => a + b, 0);
                    avgRating = (sum / ratings.length).toFixed(2);
                }
            }

            return { memberSince, avgRating };
        }

        function processAllData(tripData, orderData, profileData, ratingsData) {
            const tripAnalysis = analyzeTrips(tripData);
            const orderAnalysis = analyzeOrders(orderData);
            const profile = getProfileInfo(profileData, ratingsData);

            const allYears = new Set([...Object.keys(tripAnalysis.years), ...Object.keys(orderAnalysis.years)]);
            const sortedYears = Array.from(allYears).sort((a, b) => b - a);

            const yearsData = {};

            yearsData['Lifetime'] = {
                trips: tripAnalysis.lifetime,
                eats: orderAnalysis.lifetime
            };

            const defaultTripStats = {
                totalTrips: 0, totalSpent: "0.00", totalMiles: "0.00",
                topCities: [], timeOfDayCounts: { morning: 0, afternoon: 0, evening: 0, night: 0 },
                rideTypes: [], surgeCount: 0, avgSurgeMultiplier: 0, splitFareCount: 0, multiDestCount: 0,
                totalDurationHours: "0.0", heatmapData: { pickup: [], dropoff: [] }, maxStreak: 0,
                dayOfWeekCounts: [0, 0, 0, 0, 0, 0, 0]
            };

            const defaultOrderStats = {
                totalOrders: 0, totalSpent: "0.00", topRestaurants: [], topItems: [], maxStreak: 0,
                dayOfWeekCounts: [0, 0, 0, 0, 0, 0, 0],
                timeOfDayCounts: { morning: 0, afternoon: 0, evening: 0, night: 0 }
            };

            sortedYears.forEach(y => {
                yearsData[y] = {
                    trips: tripAnalysis.years[y] || defaultTripStats,
                    eats: orderAnalysis.years[y] || defaultOrderStats
                };
            });

            return { profile, years: yearsData };
        }

        // ==========================================
        // FILE HANDLING
        // ==========================================

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsText(file);
            });
        }

        /**
         * Find all CSV files matching a base pattern (handles numbered splits like -0, -1, -2)
         * For example, pattern 'trips_data' will match trips_data-0.csv, trips_data-1.csv, etc.
         */
        async function findAndReadAllCSVs(files, basePatterns) {
            const allData = [];
            const matchedFiles = [];
            
            // Find all files matching any of the patterns
            for (const file of files) {
                const path = (file.webkitRelativePath || file.name).toLowerCase();
                for (const pattern of basePatterns) {
                    // Match pattern with optional numbered suffix (-0, -1, etc.)
                    const patternLower = pattern.toLowerCase();
                    if (path.includes(patternLower)) {
                        matchedFiles.push(file);
                        break;
                    }
                }
            }
            
            // Sort files to ensure -0, -1, -2 order
            matchedFiles.sort((a, b) => {
                const pathA = (a.webkitRelativePath || a.name);
                const pathB = (b.webkitRelativePath || b.name);
                return pathA.localeCompare(pathB);
            });
            
            // Read and parse each file
            for (const file of matchedFiles) {
                try {
                    const content = await readFileAsText(file);
                    const parsed = Papa.parse(content, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false
                    });
                    
                    if (parsed.errors && parsed.errors.length > 0) {
                        console.warn(`Warnings/Errors parsing ${file.name}:`, parsed.errors);
                    }

                    allData.push(...parsed.data);
                    console.log(`Loaded ${parsed.data.length} rows from ${file.webkitRelativePath || file.name}`);
                } catch (e) {
                    console.warn(`Failed to read ${file.webkitRelativePath || file.name}:`, e);
                }
            }
            
            return allData;
        }

        async function processUberDataFolder(files) {
            showLoading(true);
            hideError();

            try {
                const fileArray = Array.from(files);
                
                // Find all CSV files (handles split files like -0, -1, -2, etc.)
                const tripData = await findAndReadAllCSVs(fileArray, ['rider/trips_data', 'trips_data-']);
                const orderData = await findAndReadAllCSVs(fileArray, ['eats/user_orders', 'user_orders-']);
                const profileData = await findAndReadAllCSVs(fileArray, ['account and profile/user_profile', 'user_profile-']);
                const ratingsData = await findAndReadAllCSVs(fileArray, ['rider/rider_lifetime_ratings', 'rider_lifetime_ratings_received-']);

                console.log(`Total: ${tripData.length} trips, ${orderData.length} order items`);

                if (tripData.length === 0 && orderData.length === 0) {
                    throw new Error('No Uber data found. Make sure you selected the correct "Uber Data" folder containing your trip and order history.');
                }

                const data = processAllData(tripData, orderData, profileData, ratingsData);
                
                window.UBER_DATA = data;
                showLoading(false);
                showDashboard();
                initializeDashboard();

            } catch (err) {
                console.error('Error processing data:', err);
                showLoading(false);
                showError(err.message || 'Failed to process data. Please try again.');
            }
        }

        // ==========================================
        // UI HELPERS
        // ==========================================

        function showLoading(show) {
            document.getElementById('loading-indicator').style.display = show ? 'flex' : 'none';
            document.getElementById('dropzone').style.display = show ? 'none' : 'flex';
        }

        function showError(message) {
            const errorEl = document.getElementById('error-message');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error-message').style.display = 'none';
        }

        function showDashboard() {
            document.getElementById('dropzone-screen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
        }

        function showDropzone() {
            document.getElementById('dropzone-screen').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
            showLoading(false);
            hideError();
        }

        // ==========================================
        // DASHBOARD RENDERING 
        // ==========================================

        let map = null;
        let pickupLayer = null;
        let dropoffLayer = null;
        let currentMode = 'rides';
        let currentYearStats = null;
        let currentYearLabel = 'Lifetime';

        function initializeDashboard() {
            const data = window.UBER_DATA;
            if (!data) return;

            // Profile
            const profileDiv = document.getElementById('profile-section');
            if (data.profile) {
                profileDiv.innerHTML = `
                    <div class="profile-item"><span>Member Since</span> <b>${data.profile.memberSince}</b></div>
                    <div class="profile-item"><span>Rating</span> <b>${data.profile.avgRating} ‚òÖ</b></div>
                `;
            }

            // Year Selector
            const yearSelect = document.getElementById('year-select');
            yearSelect.innerHTML = '';
            const years = Object.keys(data.years);

            const sortedYears = years.slice().sort((a, b) => {
                if (a === 'Lifetime') return -1;
                if (b === 'Lifetime') return 1;
                return Number(b) - Number(a);
            });

            sortedYears.forEach(year => {
                const opt = document.createElement('option');
                opt.value = year;
                opt.textContent = year;
                yearSelect.appendChild(opt);
            });

            // Mode Toggles
            document.getElementById('mode-rides').addEventListener('click', () => switchMode('rides'));
            document.getElementById('mode-eats').addEventListener('click', () => switchMode('eats'));

            // Default to most recent year
            const defaultYear = sortedYears.length > 1 ? sortedYears[1] : sortedYears[0];
            if (defaultYear) {
                yearSelect.value = defaultYear;
                loadYear(defaultYear);
            }

            yearSelect.addEventListener('change', (e) => {
                loadYear(e.target.value);
            });
        }

        function switchMode(mode) {
            currentMode = mode;
            
            // Toggle Buttons
            document.getElementById('mode-rides').classList.toggle('active', mode === 'rides');
            document.getElementById('mode-eats').classList.toggle('active', mode === 'eats');

            // Toggle Sections
            document.getElementById('rides-section').style.display = mode === 'rides' ? 'block' : 'none';
            document.getElementById('eats-section').style.display = mode === 'eats' ? 'block' : 'none';

            // Update Hero
            updateHero();
            
            // Update Map if Rides
            if (mode === 'rides' && map) {
                setTimeout(() => map.invalidateSize(), 100);
            }
        }

        function updateHero() {
            if (!currentYearStats) return;

            const trips = currentYearStats.trips;
            const eats = currentYearStats.eats;
            
            // Animate Title
            const titleEl = document.getElementById('hero-title');
            titleEl.style.opacity = '0';
            setTimeout(() => {
                titleEl.textContent = currentMode === 'rides' ? 'Rides Wrapped' : 'Eats Wrapped';
                titleEl.style.opacity = '1';
            }, 200);

            // Primary Stat
            const primaryVal = currentMode === 'rides' ? trips.totalTrips : eats.totalOrders;
            const primaryLabel = currentMode === 'rides' ? 'Rides' : 'Orders';
            
            animateValue("hero-primary-value", 0, primaryVal, 1000);
            document.getElementById("hero-primary-label").textContent = primaryLabel;

            // Meta Row
            const metaRow = document.getElementById('hero-meta-row');
            metaRow.innerHTML = '';

            if (currentMode === 'rides') {
                metaRow.innerHTML += `<div class="hero-meta-item"><span>${Math.round(trips.totalMiles).toLocaleString()}</span> <small>Miles</small></div>`;
                metaRow.innerHTML += `<div class="hero-meta-item"><span>$${trips.totalSpent}</span> <small>Spent</small></div>`;
            } else {
                metaRow.innerHTML += `<div class="hero-meta-item"><span>$${eats.totalSpent}</span> <small>Spent</small></div>`;
                const avgOrder = eats.totalOrders > 0 ? (parseFloat(eats.totalSpent)/eats.totalOrders).toFixed(2) : '0';
                metaRow.innerHTML += `<div class="hero-meta-item"><span>$${avgOrder}</span> <small>/ Order</small></div>`;
            }
        }

        function loadYear(year) {
            const data = window.UBER_DATA;
            const yearData = data.years[year];
            if (!yearData) return;

            currentYearStats = yearData;
            currentYearLabel = year;
            updateHero();

            // --- RIDES ---
            const trips = yearData.trips;
            
            // Map
            renderMap(trips.heatmapData);

            // Charts
            renderDayOfWeekChart('day-of-week-chart', trips.dayOfWeekCounts);
            renderTimeChart(trips.timeOfDayCounts);

            // Lists
            renderList("top-cities", trips.topCities, "trips", "city");

            // Highlights
            renderHighlights('rides', trips);

            // --- EATS ---
            const eats = yearData.eats;
            const noEatsMsg = document.getElementById('no-eats-msg');
            const eatsSection = document.getElementById('eats-section');

            if (eats.totalOrders > 0) {
                noEatsMsg.style.display = 'none';
                renderDayOfWeekChart('eats-day-of-week-chart', eats.dayOfWeekCounts, '#05C46B');
                renderEatsTimeChart(eats.timeOfDayCounts);
                renderList("top-restaurants", eats.topRestaurants, "orders", "name");
                renderList("top-items", eats.topItems, "", "name");
                renderHighlights('eats', eats);
            } else {
                noEatsMsg.style.display = 'block';
            }
            
            // Setup Share Buttons (Pass current stats)
            document.getElementById('share-rides-btn').onclick = () => generateScreenshot('rides', year, trips);
            document.getElementById('share-eats-btn').onclick = () => generateScreenshot('eats', year, eats);
        }

        function renderHighlights(mode, stats) {
            const containerId = mode === 'rides' ? 'rides-highlights' : 'eats-highlights';
            const container = document.getElementById(containerId);
            if(!container) return;
            container.innerHTML = '';

            const addChip = (icon, label, value) => {
                container.innerHTML += `
                <div class="highlight-chip">
                    <div class="chip-icon">${icon}</div>
                    <div class="chip-content">
                        <div class="chip-value">${value}</div>
                        <div class="chip-label">${label}</div>
                    </div>
                </div>`;
            };

            if (mode === 'rides') {
                if (stats.maxStreak > 1) addChip('üî•', 'Day Streak', stats.maxStreak);
                if (stats.surgeCount > 0) addChip('‚ö°', 'Surge Rides', stats.surgeCount);
                if (stats.splitFareCount > 0) addChip('üëØ', 'Split Fares', stats.splitFareCount);
                if (stats.multiDestCount > 0) addChip('üìç', 'Multi-Stop', stats.multiDestCount);
            } else {
                if (stats.maxStreak > 1) addChip('üî•', 'Day Streak', stats.maxStreak);
            }
        }

        function renderMap(data) {
            const mapContainer = document.getElementById('trip-map');
            if (!mapContainer) return;

            const parent = mapContainer.parentElement;

            if (typeof L === 'undefined') {
                console.warn("Leaflet (L) is not defined. Map cannot be rendered.");
                if (parent) parent.style.display = 'none';
                return;
            }

            const hasData = data && (
                (data.pickup && data.pickup.length > 0) ||
                (data.dropoff && data.dropoff.length > 0)
            );

            if (!hasData) {
                if (parent) parent.style.display = 'none';
                return;
            }

            if (parent) parent.style.display = 'block';

            if (!map) {
                map = L.map('trip-map', {
                    zoomControl: false,
                    attributionControl: false
                });

                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    maxZoom: 19
                }).addTo(map);
            }

            setTimeout(() => {
                if (map) map.invalidateSize();
            }, 100);

            if (pickupLayer) {
                try { map.removeLayer(pickupLayer); } catch (e) { }
            }
            if (dropoffLayer) {
                try { map.removeLayer(dropoffLayer); } catch (e) { }
            }

            if (typeof L.heatLayer === 'function') {
                if (data.pickup && data.pickup.length > 0) {
                    pickupLayer = L.heatLayer(data.pickup, {
                        radius: 12,
                        blur: 20,
                        maxZoom: 12,
                        gradient: { 0.4: '#00f2ff', 0.65: '#00c3ff', 1: '#0044ff' }
                    }).addTo(map);
                }

                if (data.dropoff && data.dropoff.length > 0) {
                    dropoffLayer = L.heatLayer(data.dropoff, {
                        radius: 12,
                        blur: 20,
                        maxZoom: 12,
                        gradient: { 0.4: '#ff9d00', 0.65: '#ff0000', 1: '#fff' }
                    }).addTo(map);
                }

                const allPoints = [...(data.pickup || []), ...(data.dropoff || [])];
                if (allPoints.length > 0) {
                    map.fitBounds(allPoints, { padding: [20, 20] });
                }
            } else {
                console.warn("Leaflet.heat is not loaded.");
            }
        }

        function renderList(containerId, list, suffix, keyName) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            if (!list || list.length === 0) {
                container.innerHTML = '<div style="opacity:0.5; font-size:0.9rem;">No data available</div>';
                return;
            }
            list.forEach(item => {
                const el = document.createElement('div');
                el.className = 'list-item';

                let rightText = suffix ? `${item.count} ${suffix}` : item.count;

                if (item.spend) {
                    rightText = `<span>$${item.spend}</span> <span style="font-size:0.8em; opacity:0.7">(${item.count})</span>`;
                }

                el.innerHTML = `<span>${item[keyName] || item.city || item.type || item.name}</span> <span>${rightText}</span>`;
                container.appendChild(el);
            });
        }

        function renderTimeChart(times) {
            const container = document.getElementById('time-chart');
            if (!container) return;
            container.innerHTML = '';

            if (!times) return;

            const maxVal = Math.max(times.morning || 0, times.afternoon || 0, times.evening || 0, times.night || 0) || 1;
            const timeLabels = { morning: 'Morning', afternoon: 'Afternoon', evening: 'Evening', night: 'Night' };

            Object.keys(timeLabels).forEach(k => {
                const count = times[k] || 0;
                const pct = (count / maxVal) * 100;
                const bar = document.createElement('div');
                bar.className = `bar ${k}`;
                bar.style.height = '4px';
                bar.innerHTML = `
                    <div class="bar-tooltip">${count} rides</div>
                    <div class="bar-label">${timeLabels[k]}</div>
                `;
                container.appendChild(bar);

                setTimeout(() => {
                    bar.style.height = Math.max(pct, 5) + '%';
                }, 200);
            });
        }

        function renderEatsTimeChart(times) {
            const container = document.getElementById('eats-time-chart');
            if (!container) return;
            container.innerHTML = '';

            if (!times) return;

            const maxVal = Math.max(times.morning || 0, times.afternoon || 0, times.evening || 0, times.night || 0) || 1;
            const timeLabels = { morning: 'Morning', afternoon: 'Afternoon', evening: 'Evening', night: 'Night' };

            Object.keys(timeLabels).forEach(k => {
                const count = times[k] || 0;
                const pct = (count / maxVal) * 100;
                const bar = document.createElement('div');
                bar.className = `bar ${k}`;
                bar.style.height = '4px';
                bar.innerHTML = `
                    <div class="bar-tooltip">${count} orders</div>
                    <div class="bar-label">${timeLabels[k]}</div>
                `;
                container.appendChild(bar);

                setTimeout(() => {
                    bar.style.height = Math.max(pct, 5) + '%';
                }, 200);
            });
        }


        let charts = {}; // Store charts to destroy them before re-rendering

        function renderChart(canvasId, labels, data, animate = true) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            charts[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#276EF1',
                            '#05C46B',
                            '#FFD700',
                            '#FF4500',
                            '#888888',
                            '#ffffff'
                        ],
                        borderWidth: 0,
                    }]
                },
                options: {
                    animation: animate ? {} : false,
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#A0A0A0',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                },
                                boxWidth: 12
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: { weight: 'bold', size: 10 },
                            formatter: (value, ctx) => {
                                let sum = 0;
                                let dataArr = ctx.chart.data.datasets[0].data;
                                dataArr.map(data => { sum += data; });
                                let percentage = (value * 100 / sum).toFixed(0) + "%";
                                return percentage;
                            },
                            display: (context) => {
                                let dataset = context.dataset;
                                let value = dataset.data[context.dataIndex];
                                let total = dataset.data.reduce((a, b) => a + b, 0);
                                return value > (total * 0.05); // Only show if > 5%
                            }
                        }
                    },
                    cutout: '60%'
                },
                plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
            });
        }

        function renderDayOfWeekChart(canvasId, data, color = '#276EF1', animate = true) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            // Defensive check for data
            const chartData = (data && Array.isArray(data)) ? data : [0, 0, 0, 0, 0, 0, 0];
            
            // Log empty data for debugging but don't alert
            if (chartData.every(v => v === 0)) {
                console.warn(`Chart ${canvasId} has all zero data - check if data has dayOfWeekCounts`);
            }
            
            const ctx = canvas.getContext('2d');
            
            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            charts[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    datasets: [{
                        data: chartData,
                        backgroundColor: color,
                        borderRadius: 4
                    }]
                },
                options: {
                    animation: animate ? {} : false,
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        datalabels: { display: false }
                    },
                    scales: {
                        y: {
                            display: false,
                            beginAtZero: true,
                            grid: { display: false }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: '#A0A0A0', font: { family: 'Inter' } }
                        }
                    }
                }
            });
        }

        function generateScreenshot(type, year, stats) {
            try {
                const templateId = type === 'rides' ? 'rides-share-template' : 'eats-share-template';
                const template = document.getElementById(templateId);
                
                // Populate Template Data
                if (type === 'rides') {
                document.getElementById('share-rides-year').textContent = year === 'Lifetime' ? 'All Time' : year;
                document.getElementById('share-rides-count').textContent = stats.totalTrips;
                document.getElementById('share-rides-miles').textContent = Math.round(parseFloat(stats.totalMiles)).toLocaleString();
                
                // Populating lists in template
                const destContainer = document.getElementById('share-rides-destinations');
                destContainer.innerHTML = '';
                stats.topCities.slice(0, 3).forEach(item => {
                    destContainer.innerHTML += `
                        <div class="list-row">
                            <span class="list-row-name">${item.city}</span>
                            <span class="list-row-count">${item.count}</span>
                        </div>`;
                });
                
                // Moved Ride Types out of screenshot as requested by user
                
                // Weekly Habits (Day of Week)
                renderDayOfWeekChart('share-rides-dow-chart', stats.dayOfWeekCounts || [0,0,0,0,0,0,0], '#276EF1', false);

                // Streak Badge for Rides
                const streakBadge = document.getElementById('share-rides-streak-badge');
                if (stats.maxStreak > 1) {
                    streakBadge.style.display = 'flex';
                    document.getElementById('share-rides-streak').textContent = stats.maxStreak;
                } else {
                    streakBadge.style.display = 'none';
                }

                // Time Chart for Share
                 const timeContainer = document.getElementById('share-rides-time-chart');
                 timeContainer.innerHTML = '';
                 const times = stats.timeOfDayCounts;
                 const maxVal = Math.max(times.morning || 0, times.afternoon || 0, times.evening || 0, times.night || 0) || 1;
                 const timeLabels = { morning: 'Morning', afternoon: 'Afternoon', evening: 'Evening', night: 'Night' };
                 Object.keys(timeLabels).forEach(k => {
                    const count = times[k] || 0;
                    const pct = (count / maxVal) * 100;
                    timeContainer.innerHTML += `
                        <div class="time-bar">
                            <div class="time-bar-fill ${k}" style="height: ${Math.max(pct, 5)}%"></div>
                            <div class="time-bar-label">${timeLabels[k]}</div>
                        </div>`;
                 });

            } else {
                document.getElementById('share-eats-year').textContent = year === 'Lifetime' ? 'All Time' : year;
                document.getElementById('share-eats-count').textContent = stats.totalOrders;
                
                const restContainer = document.getElementById('share-eats-restaurants');
                restContainer.innerHTML = '';
                stats.topRestaurants.slice(0, 4).forEach(item => {
                    restContainer.innerHTML += `
                        <div class="list-row">
                            <span class="list-row-name">${item.name}</span>
                            <span class="list-row-count">${item.count}</span>
                        </div>`;
                });

                const itemsContainer = document.getElementById('share-eats-items');
                itemsContainer.innerHTML = '';
                stats.topItems.slice(0, 4).forEach(item => {
                    itemsContainer.innerHTML += `
                        <div class="list-row">
                            <span class="list-row-name">${item.name}</span>
                            <span class="list-row-count">${item.count}</span>
                        </div>`;
                });

                // Streak Badge for Eats
                 const streakBadge = document.getElementById('share-eats-streak-badge');
                 if (stats.maxStreak > 1) {
                     streakBadge.style.display = 'flex';
                     document.getElementById('share-eats-streak').textContent = stats.maxStreak;
                 } else {
                     streakBadge.style.display = 'none';
                 }

                 // Eats Day of Week Chart (Green)
                 renderDayOfWeekChart('share-eats-dow-chart', stats.dayOfWeekCounts || [0,0,0,0,0,0,0], '#05C46B', false);
            }

            // Generate Image
            // Small delay to ensure chart renders (even with no animation, canvas needs a tick)
            setTimeout(() => {
                html2canvas(template, {
                    scale: 2, // Better quality
                    backgroundColor: null,
                    logging: false,
                    useCORS: true
                }).then(canvas => {
                    const filename = `UberWrapped-${type}-${year}.png`;
                    
                    // Universal download function that works across all browsers
                    const downloadImage = async (blob) => {
                        const pngBlob = new Blob([blob], { type: 'image/png' });
                        
                        // Check if Web Share API with files is supported (iOS Safari, some Android)
                        // This allows saving directly to Photos on iOS
                        if (navigator.canShare && navigator.canShare({ files: [new File([pngBlob], filename, { type: 'image/png' })] })) {
                            try {
                                const file = new File([pngBlob], filename, { type: 'image/png' });
                                await navigator.share({
                                    files: [file],
                                    title: 'Uber Wrapped',
                                    text: 'My Uber Wrapped ' + year
                                });
                                return; // Share successful
                            } catch (err) {
                                // User cancelled or share failed, fall through to download
                                if (err.name !== 'AbortError') {
                                    console.log('Share failed, falling back to download:', err);
                                } else {
                                    return; // User cancelled, don't download
                                }
                            }
                        }
                        
                        // Fallback: Standard download (desktop browsers, non-iOS)
                        const url = URL.createObjectURL(pngBlob);
                        const link = document.createElement('a');
                        link.style.display = 'none';
                        link.href = url;
                        link.download = filename;
                        link.setAttribute('download', filename);
                        link.setAttribute('target', '_blank');
                        document.body.appendChild(link);
                        
                        // Use a small timeout to ensure the link is in the DOM
                        setTimeout(() => {
                            link.click();
                            // Cleanup
                            setTimeout(() => {
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                            }, 250);
                        }, 100);
                    };
                    
                    // Convert canvas to blob with explicit type
                    canvas.toBlob(blob => {
                        if (!blob) {
                            console.error('Failed to create blob from canvas');
                            alert('Failed to generate screenshot. Please try again.');
                            return;
                        }
                        
                        downloadImage(blob);
                    }, 'image/png', 1.0);
                }).catch(err => {
                    console.error('Screenshot failed:', err);
                    alert('Failed to generate screenshot: ' + err.message);
                });
            }, 500); 
            } catch (e) {
                console.error("Error preparing screenshot:", e);
                alert("Error preparing screenshot: " + e.message);
            }
        }

        function animateValue(id, start, end, duration) {
            const obj = document.getElementById(id);
            if (!obj) return;
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    obj.innerHTML = end;
                }
            };
            window.requestAnimationFrame(step);
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================

        document.addEventListener('DOMContentLoaded', () => {
            const dropzone = document.getElementById('dropzone');
            const folderInput = document.getElementById('folder-input');
            const selectBtn = document.getElementById('select-folder-btn');
            const resetBtn = document.getElementById('reset-btn');

            // Try to auto-load data.js if it exists
            tryLoadPreGeneratedData().then(loaded => {
                if (loaded) {
                    // Data found, show dashboard directly
                    showDashboard();
                    initializeDashboard();
                }
                // Otherwise dropzone is already visible
            });

            // Click to select folder
            selectBtn.addEventListener('click', () => {
                folderInput.click();
            });

            dropzone.addEventListener('click', (e) => {
                if (e.target !== selectBtn) {
                    folderInput.click();
                }
            });

            // Folder input change
            folderInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processUberDataFolder(e.target.files);
                }
            });

            // Drag and drop
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('drag-over');
            });

            dropzone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropzone.classList.remove('drag-over');
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('drag-over');

                const items = e.dataTransfer.items;
                if (items) {
                    const files = [];
                    const promises = [];

                    for (const item of items) {
                        if (item.kind === 'file') {
                            const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                            if (entry && entry.isDirectory) {
                                promises.push(scanDirectory(entry, files));
                            } else {
                                files.push(item.getAsFile());
                            }
                        }
                    }

                    Promise.all(promises).then(() => {
                        if (files.length > 0) {
                            processUberDataFolder(files);
                        }
                    });
                }
            });

            // Reset button
            resetBtn.addEventListener('click', () => {
                window.UBER_DATA = null;
                map = null;
                pickupLayer = null;
                dropoffLayer = null;
                document.getElementById('trip-map').innerHTML = '';
                showDropzone();
            });
        });

        // Try to load pre-generated data.js file
        function tryLoadPreGeneratedData() {
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'data.js';
                
                script.onload = () => {
                    // Check if UBER_DATA was defined by the script
                    if (window.UBER_DATA && window.UBER_DATA.years) {
                        console.log('Loaded pre-generated data.js');
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                };
                
                script.onerror = () => {
                    // data.js doesn't exist, show dropzone
                    console.log('No data.js found, showing dropzone');
                    resolve(false);
                };
                
                document.head.appendChild(script);
            });
        }

        // Recursive directory scanner for drag-and-drop
        function scanDirectory(entry, files) {
            return new Promise((resolve) => {
                if (entry.isFile) {
                    entry.file(file => {
                        file.webkitRelativePath = entry.fullPath;
                        files.push(file);
                        resolve();
                    });
                } else if (entry.isDirectory) {
                    const reader = entry.createReader();
                    reader.readEntries(entries => {
                        const promises = entries.map(e => scanDirectory(e, files));
                        Promise.all(promises).then(resolve);
                    });
                } else {
                    resolve();
                }
            });
        }
    </script>
</body>
</html>
